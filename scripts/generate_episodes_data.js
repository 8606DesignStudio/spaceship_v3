const fs = require('fs');
const path = require('path');

// Read and parse the CSV file
function parseCSV() {
    const csvPath = path.join(__dirname, '../data/export.csv');
    const csvContent = fs.readFileSync(csvPath, 'utf-8');
    
    // Split into lines and remove the header
    const lines = csvContent.split('\n').slice(1);
    
    const episodes = {};
    
    lines.forEach(line => {
        if (!line.trim()) return; // Skip empty lines
        
        // Parse CSV line (handling quoted fields that may contain commas)
        const fields = parseCSVLine(line);
        
        if (fields.length >= 2) {
            const title = fields[0];
            const link = fields[1];
            
            // Extract episode number from title using regex
            const episodeMatch = title.match(/#(\d+)/);
            if (episodeMatch) {
                const episodeNum = parseInt(episodeMatch[1]);
                episodes[episodeNum] = `<a href="${link}">${title}</a>`;
            }
        }
    });
    
    return episodes;
}

// Simple CSV line parser that handles quoted fields
function parseCSVLine(line) {
    const fields = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
                // Escaped quote
                current += '"';
                i++; // Skip next quote
            } else {
                // Toggle quote state
                inQuotes = !inQuotes;
            }
        } else if (char === ',' && !inQuotes) {
            // Field separator
            fields.push(current);
            current = '';
        } else {
            current += char;
        }
    }
    
    // Add the last field
    fields.push(current);
    
    return fields;
}

// Generate the episodes array
function generateEpisodesArray() {
    const episodeData = parseCSV();
    
    // Find the maximum episode number
    const maxEpisode = Math.max(...Object.keys(episodeData).map(Number));
    
    // Create array with proper size (maxEpisode + 1 to include index 0)
    const episodes = new Array(maxEpisode + 1).fill('');
    
    // Set the welcome message at index 0
    episodes[0] = "start scrolling <3";
    
    // Fill in the episodes
    Object.keys(episodeData).forEach(episodeNum => {
        episodes[parseInt(episodeNum)] = episodeData[episodeNum];
    });
    
    return episodes;
}

// Write the generated data to a JavaScript file
function writeEpisodesFile() {
    const episodes = generateEpisodesArray();
    
    const jsContent = `// Auto-generated from data/export.csv
// Do not edit this file manually - run 'node scripts/generate_episodes_data.js' to regenerate

export const episodes = ${JSON.stringify(episodes, null, 2)};
`;
    
    const outputPath = path.join(__dirname, '../data/generatedEpisodes.js');
    
    // Ensure the data directory exists
    const dataDir = path.dirname(outputPath);
    if (!fs.existsSync(dataDir)) {
        fs.mkdirSync(dataDir, { recursive: true });
    }
    
    fs.writeFileSync(outputPath, jsContent);
    
    console.log(`‚úÖ Generated episodes data with ${episodes.length} entries`);
    console.log(`üìÅ Written to: ${outputPath}`);
    console.log(`üéØ Latest episode: #${episodes.length - 1}`);
}

// Run the generation
try {
    writeEpisodesFile();
} catch (error) {
    console.error('‚ùå Error generating episodes data:', error.message);
    process.exit(1);
}